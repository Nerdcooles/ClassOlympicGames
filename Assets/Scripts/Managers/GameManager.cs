using UnityEngine;using System.Collections.Generic;using System.Linq;/** * Game data */public class GameManager : Singleton<GameManager>{	/**	 * Players ID	 */	public enum ePlayers	{		p01,		p02,		p03,		p04,		none}	;	public enum eMedals	{		Gold,		Silver,		Bronze}	;	public enum eGameMode	{		CLASSIC,		TRAINING}	;	public enum eLevels	{		Menu,		Delaybus,		Bucketball,		Arteachery,		SkipTheTest,		LongboardJump,		Nerdthrow ,		Award}	;	public enum eColors	{		blue,		green,		red,		yellow}	;	private int currentMenu = 0;	Dictionary<ePlayers, Player> players = new Dictionary<ePlayers, Player> ();	private eGameMode gameMode;	private eLevels level = eLevels.Menu;			protected GameManager ()	{	} // guarantee this will be always a singleton only - can't use the constructor!	public eGameMode GetGameMode ()	{		return gameMode;	}	public int GetNumPlayer ()	{		return players.Count ();	}	public List<ePlayers> GetPlayers ()	{		List<ePlayers> ps = new List<ePlayers> (players.Keys);		return ps;	}	/* CLASSIC RANK: WHO HAS MORE GOLDS WINS	public List<ePlayers> getWinners() {		List<Player> playersToCtrl = new List<Player>();		List<ePlayers> winners = new List<ePlayers> ();		//populate list to control		for (int i=0; i<players.Count; i++)			playersToCtrl.Add (players [(ePlayers)i]);		while (playersToCtrl.Count > 0) {			ePlayers winner = WhoHasMoreMedals(playersToCtrl, eMedals.Gold).Number;			winners.Add(winner);			playersToCtrl.Remove(players[winner]);		}		return winners;	}	Player WhoHasMoreMedals(List<Player> playersToCtrl, eMedals medal) {		//find max golds value		int max_medals = 0;		foreach (Player p in playersToCtrl) {			int medals = p.getMedals (medal);			if (medals > max_medals) {				max_medals = medals;			}		}		//store players with max golds value		List<Player> results = new List<Player>();		foreach (Player p in playersToCtrl) {			if (p.getMedals (medal) == max_medals) {				results.Add(p);			}		}		if(results.Count > 1 && medal.GetHashCode()!=2) {			//if more then one, repeat			return WhoHasMoreMedals(results, (eMedals)(medal.GetHashCode()+1));		}else{			return results[0];		}	}	*/	/*CUSTOM RANK: EACH MEDALS HAS A VALUE*/	/**	 * Get ePlayers in order of scores	 * 	 * \param drawAllowed if draw is allowed	 * \throw DrawException if draw is reached	 * \return List of ePlayers in order of scores	 */	public List<ePlayers> GetWinners (bool drawAllowed)	{		List<Player> playersToCtrl = new List<Player> ();		List<ePlayers> winners = new List<ePlayers> ();				//populate list to control		for (int i=0; i<players.Count; i++)			playersToCtrl.Add (players [(ePlayers)i]);						while (playersToCtrl.Count > 0) {			int max = -1;			ePlayers winner = ePlayers.none;			foreach (Player p in playersToCtrl) {				if (p.Points == max && !drawAllowed)					throw new DrawException ("More than one player with same points");				if (p.Points > max) {					winner = p.Number;					max = p.Points;				}			}							winners.Add (winner);			playersToCtrl.Remove (players [winner]);		}				return winners;	}	public void AddMedal (ePlayers player, eMedals medal)	{		if (players.ContainsKey (player) && medal.GetHashCode () != 3) {			players [player].AddMedal (medal);		}	}	public int GetMedal (ePlayers player, eMedals medal)	{		if (players.ContainsKey (player))			return players [player].GetMedals (medal);		else			return 0;	}	public int GetPoints (ePlayers player)	{		if (players.ContainsKey (player))			return players [player].Points;		else			return 0;	}	public bool IsPlaying (ePlayers player)	{		if (players.ContainsKey (player)) {			return true;		} else {			return false;		}	}	public void StartMode (eGameMode mode)	{		level = eLevels.Menu;		this.gameMode = mode;	}	public void CreatePlayers (int num_players)	{		players = new Dictionary<ePlayers, Player> ();				for (int i=0; i<num_players; i++) {			Player p = new Player ();			p.Number = (ePlayers)i;			players.Add ((ePlayers)i, p);		}	}	public void SetColor (ePlayers player, eColors color)	{		if (players.ContainsKey (player)) {			players [player].Color = color;		}	}	public eColors GetColor (ePlayers player)	{		return players [player].Color;	}		public Color GetSysColor (ePlayers player)	{		switch (players [player].Color) {		case eColors.blue:			return new Color (93 / 255f, 93 / 255f, 244 / 255f, 255 / 255f);			break;		case eColors.red:			return new Color (255 / 255f, 68 / 255f, 68 / 255f, 255 / 255f);			break;		case eColors.yellow:			return new Color (246 / 255f, 229 / 255f, 38 / 255f, 255 / 255f);			break;		case eColors.green:			return new Color (111 / 255f, 255 / 255f, 11 / 255f, 255 / 255f);			break;		default:			throw new System.Exception ("Player get color error");		}	}	public void LevelOver ()	{		MenuManager.LevelOver ();	}	public eLevels Level {		get {			return level;		}		set {			level = value;		}	}		public int CurrentMenu {		get {			return currentMenu;		}		set {			currentMenu = value;		}	}}/** * Draw Exception */public class DrawException: System.Exception{	public DrawException ()	{	}		public DrawException (string message)		: base(message)	{	}}